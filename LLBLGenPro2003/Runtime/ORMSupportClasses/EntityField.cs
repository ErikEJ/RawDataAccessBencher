/////////////////////////////////////////////////////////////
// LLBLGen Pro ORM Support Classes Library
// (c) 2002-2003 Solutions Design. All rights reserved.
// http://www.llblgen.com
// http://www.sd.nl/llblgen
// 
// THIS IS NOT OPEN SOURCE SOFTWARE OF ANY KIND.
// SOURCECODE DISTRIBUTION IS NOT ALLOWED IN ANY WAY.
/////////////////////////////////////////////////////////////
using System;
using System.ComponentModel;
using System.Xml;
using System.Xml.Serialization;
using System.IO;

namespace SD.LLBLGen.Pro.ORMSupportClasses2003
{
	/// <summary>
	/// Generic class which is used for the columns in the EntityFields collection, which forms the data store of
	/// any Entity class generated by LLBLGen Pro. 
	/// </summary>
	[Serializable]
	public class EntityField: IEntityField, ICloneable, IComparable
	{
		#region Class Member Declarations
		private	string			_name, _sourceColumnName, _sourceObjectName, _sourceSchemaName, _identityValueSequenceName, _sourceCatalogName;
		private System.Type		_dataType;
		private object			_currentValue, _originalValue;
		private bool			_isChanged, _isReadOnly, _isSourceColumnNullable, _isNull, _isPrimaryKey, _isIdentity;
		private int				_sourceColumnMaxLength, _sourceColumnDbType, _fieldIndex;
		private byte			_sourceColumnScale, _sourceColumnPrecision;
		#endregion
		

		/// <summary>
		/// CTor. Necessary for serialization. Do not use this CTor in code.
		/// </summary>
		public EntityField()
		{
			_name = String.Empty;
			_sourceColumnName = String.Empty;
			_sourceObjectName = String.Empty;
			_sourceSchemaName = String.Empty;
			_sourceCatalogName = String.Empty;
			_identityValueSequenceName = String.Empty;
			_dataType=null;
			_currentValue=null;
			_originalValue=null;
		}

		
		/// <summary>
		/// CTor
		/// </summary>
		/// <param name="name">The name of the field. Used in XML output. </param>
		/// <param name="dataType">The <see cref="System.Type"/> of the values of this field.</param>
		/// <param name="isReadOnly">If set to true, no changes can be made to this field.</param>
		/// <param name="sourceSchemaName">The name of the schema which holds SourceObjectName. Schema is used to generate SQL on the fly. A common schema name in SqlServer is f.e. 'dbo'.</param>
		/// <param name="sourceObjectName">The name of the source object which holds SourceColumnName. Can be a view or a table. Used to generate SQL on the fly.</param>
		/// <param name="sourceColumnName">The name of the corresponding column in a view or table for this entityfield. This name is used to map a column in a resultset onto the entity field.</param>
		/// <param name="isSourceColumnNullable">Flag if the Column mapped onto the entityfield is nullable or not. </param>
		/// <param name="sourceColumnDbType">The type of the Column mapped onto the EntityField. The value stored here is the integer representation of the enum value of the type, f.e.
		/// SqlDbType.Int or OracleType.Int16</param>
		/// <param name="sourceColumnMaxLength">The maximum length of the value of this entityfield (string/binary data). Is ignored for 
		/// entityfields which hold non-string and non-binary values.</param>
		/// <param name="sourceColumnScale">The scale of the Column mapped onto the entityfield.</param>
		/// <param name="sourceColumnPrecision">The precision of the Column mapped onto the entityfield.</param>
		/// <param name="isPrimaryKey">If set to true, this field will end up in the PrimaryKey field list of the containing IEntityFields object.</param>
		/// <param name="isIdentity">If set to true, the Dynamic Query Engine (DQE) will assume the field is an Identity field and will act accordingly (i.e.: as the target database
		/// handles Identity fields: SqlServer will generate a new value itself, Oracle wants to have a sequence input.</param>
		/// <param name="identityValueSequenceName">If isIdentity is set to true, this property has to be set to the name of the sequence which supplies the value for the EntityField's
		/// corresponding table field. On SqlServer this is @@IDENTITY or SCOPE_IDENTITY() and only used when the row is succesfully inserted, however on Oracle
		/// f.e. this value is used to specify a new value and to retrieve the new value. Is undefined when isIdentity is set to false.</param>
		/// <param name="fieldIndex">the field index related to this IEntityField, so the field can be used to retrieve the field index.</param>
		public EntityField(string name, System.Type dataType, bool isReadOnly, string sourceSchemaName, string sourceObjectName, string sourceColumnName, 
				bool isSourceColumnNullable, int sourceColumnDbType, int sourceColumnMaxLength, byte sourceColumnScale, byte sourceColumnPrecision, 
				bool isPrimaryKey, bool isIdentity, string identityValueSequenceName, int fieldIndex)
		{
			InitClass(name, dataType, isReadOnly, null, sourceSchemaName, sourceObjectName, sourceColumnName, isSourceColumnNullable, 
					sourceColumnDbType, sourceColumnMaxLength, sourceColumnScale, sourceColumnPrecision, isPrimaryKey, isIdentity, identityValueSequenceName, fieldIndex, String.Empty);
		}


		/// <summary>
		/// CTor
		/// </summary>
		/// <param name="name">The name of the field. Used in XML output. </param>
		/// <param name="dataType">The <see cref="System.Type"/> of the values of this field.</param>
		/// <param name="isReadOnly">If set to true, no changes can be made to this field.</param>
		/// <param name="currentValue">The current value for this field.</param>
		/// <param name="sourceSchemaName">The name of the schema which holds SourceObjectName. Schema is used to generate SQL on the fly. A common schema name in SqlServer is f.e. 'dbo'.</param>
		/// <param name="sourceObjectName">The name of the source object which holds SourceColumnName. Can be a view or a table. Used to generate SQL on the fly.</param>
		/// <param name="sourceColumnName">The name of the corresponding column in a view or table for this entityfield. This name is used to map a column in a resultset onto the entity field.</param>
		/// <param name="isSourceColumnNullable">Flag if the Column mapped onto the entityfield is nullable or not. </param>
		/// <param name="sourceColumnDbType">The type of the Column mapped onto the EntityField. The value stored here is the integer representation of the enum value of the type, f.e.
		/// SqlDbType.Int or OracleType.Int16</param>
		/// <param name="sourceColumnMaxLength">The maximum length of the value of this entityfield (string/binary data). Is ignored for entityfields which hold non-string and non-binary values.ColumnMaxLength</param>
		/// <param name="sourceColumnScale">The scale of the Column mapped onto the entityfield.</param>
		/// <param name="sourceColumnPrecision">The precision of the Column mapped onto the entityfield.</param>
		/// <param name="isPrimaryKey">If set to true, this field will end up in the PrimaryKey field list of the containing IEntityFields object.</param>
		/// <param name="isIdentity">If set to true, the Dynamic Query Engine (DQE) will assume the field is an Identity field and will act accordingly (i.e.: as the target database
		/// handles Identity fields: SqlServer will generate a new value itself, Oracle wants to have a sequence input.</param>
		/// <param name="identityValueSequenceName">If isIdentity is set to true, this property has to be set to the name of the sequence which supplies the value for the EntityField's
		/// corresponding table field. On SqlServer this is @@IDENTITY or SCOPE_IDENTITY() and only used when the row is succesfully inserted, however on Oracle
		/// f.e. this value is used to specify a new value and to retrieve the new value. Is undefined when isIdentity is set to false.</param>
		/// <param name="fieldIndex">the field index related to this IEntityField, so the field can be used to retrieve the field index.</param>
		public EntityField(string name, System.Type dataType, bool isReadOnly, object currentValue, string sourceSchemaName, string sourceObjectName, 
					string sourceColumnName, bool isSourceColumnNullable, int sourceColumnDbType, int sourceColumnMaxLength, 
					byte sourceColumnScale, byte sourceColumnPrecision, bool isPrimaryKey, bool isIdentity, string identityValueSequenceName, int fieldIndex)
		{
			InitClass(name, dataType, isReadOnly, currentValue, sourceSchemaName, sourceObjectName, sourceColumnName, isSourceColumnNullable, 
				sourceColumnDbType, sourceColumnMaxLength, sourceColumnScale, sourceColumnPrecision, isPrimaryKey, isIdentity, identityValueSequenceName, fieldIndex, String.Empty);
		}


		/// <summary>
		/// CTor
		/// </summary>
		/// <param name="name">The name of the field. Used in XML output. </param>
		/// <param name="dataType">The <see cref="System.Type"/> of the values of this field.</param>
		/// <param name="isReadOnly">If set to true, no changes can be made to this field.</param>
		/// <param name="currentValue">The current value for this field.</param>
		/// <param name="sourceCatalogName">The name of the catalog the sourceSchemaName is located in.</param>
		/// <param name="sourceSchemaName">The name of the schema which holds SourceObjectName. Schema is used to generate SQL on the fly. A common schema name in SqlServer is f.e. 'dbo'.</param>
		/// <param name="sourceObjectName">The name of the source object which holds SourceColumnName. Can be a view or a table. Used to generate SQL on the fly.</param>
		/// <param name="sourceColumnName">The name of the corresponding column in a view or table for this entityfield. This name is used to map a column in a resultset onto the entity field.</param>
		/// <param name="isSourceColumnNullable">Flag if the Column mapped onto the entityfield is nullable or not. </param>
		/// <param name="sourceColumnDbType">The type of the Column mapped onto the EntityField. The value stored here is the integer representation of the enum value of the type, f.e.
		/// SqlDbType.Int or OracleType.Int16</param>
		/// <param name="sourceColumnMaxLength">The maximum length of the value of this entityfield (string/binary data). Is ignored for entityfields which hold non-string and non-binary values.ColumnMaxLength</param>
		/// <param name="sourceColumnScale">The scale of the Column mapped onto the entityfield.</param>
		/// <param name="sourceColumnPrecision">The precision of the Column mapped onto the entityfield.</param>
		/// <param name="isPrimaryKey">If set to true, this field will end up in the PrimaryKey field list of the containing IEntityFields object.</param>
		/// <param name="isIdentity">If set to true, the Dynamic Query Engine (DQE) will assume the field is an Identity field and will act accordingly (i.e.: as the target database
		/// handles Identity fields: SqlServer will generate a new value itself, Oracle wants to have a sequence input.</param>
		/// <param name="identityValueSequenceName">If isIdentity is set to true, this property has to be set to the name of the sequence which supplies the value for the EntityField's
		/// corresponding table field. On SqlServer this is @@IDENTITY or SCOPE_IDENTITY() and only used when the row is succesfully inserted, however on Oracle
		/// f.e. this value is used to specify a new value and to retrieve the new value. Is undefined when isIdentity is set to false.</param>
		/// <param name="fieldIndex">the field index related to this IEntityField, so the field can be used to retrieve the field index.</param>
		public EntityField(string name, System.Type dataType, bool isReadOnly, object currentValue, string sourceCatalogName, string sourceSchemaName, string sourceObjectName, 
			string sourceColumnName, bool isSourceColumnNullable, int sourceColumnDbType, int sourceColumnMaxLength, 
			byte sourceColumnScale, byte sourceColumnPrecision, bool isPrimaryKey, bool isIdentity, string identityValueSequenceName, int fieldIndex)
		{
			InitClass(name, dataType, isReadOnly, currentValue, sourceSchemaName, sourceObjectName, sourceColumnName, isSourceColumnNullable, 
				sourceColumnDbType, sourceColumnMaxLength, sourceColumnScale, sourceColumnPrecision, isPrimaryKey, isIdentity, identityValueSequenceName, fieldIndex, sourceCatalogName);
		}


		/// <summary>
		/// Compares the given entityfield instance with this instance using a value compare with <b>case sensitive</b> comparer logic.
		/// this is done by comparing the name, the source schema, object and column name. If there is any mismatch, the
		/// comparisson is stopped and the result of the mismatching compare is returned.
		/// </summary>
		/// <param name="fieldToCompare">The EntityField to compare with the current value.</param>
		/// <returns>A 32-bit signed integer that indicates the relative order of the comparands. See <see cref="System.IComparable.CompareTo"/>.</returns>
		public int CompareTo(object fieldToCompare)
		{
			IEntityField comparedField = fieldToCompare as IEntityField;

			if(comparedField==null)
			{
				// not an EntityField2
				throw new ArgumentException("fieldToCompare is not of type IEntityField", "fieldToCompare");
			}

			// compare the passed in field with this instance.
			int compareResult = 0;
			compareResult = this._name.CompareTo(comparedField.Name);
			if(compareResult!=0)
			{
				// done
				return compareResult;
			}

			compareResult = this._sourceSchemaName.CompareTo(comparedField.SourceSchemaName);
			if(compareResult!=0)
			{
				// done
				return compareResult;
			}

			compareResult = this._sourceObjectName.CompareTo(comparedField.SourceObjectName);
			if(compareResult!=0)
			{
				// done
				return compareResult;
			}

			compareResult = this._sourceColumnName.CompareTo(comparedField.SourceColumnName);
			if(compareResult!=0)
			{
				// done
				return compareResult;
			}

			// compare values
			compareResult = _currentValue.ToString().CompareTo(comparedField.CurrentValue.ToString());
			return compareResult;
		}


		/// <summary>
		/// Overrides the GetHashCode() method. It will return the hashcode of the value of the field as the hashcode. 
		/// </summary>
		/// <returns>hashcode of the value of the field.</returns>
		public override int GetHashCode()
		{
			if(_currentValue!=null)
			{
				return _currentValue.GetHashCode();
			}
			else
			{
				return base.GetHashCode();
			}
		}


		/// <summary>
		/// Converts this EntityField to an XmlNode. 
		/// </summary>
		/// <returns>This EntityField in XmlNode format</returns>
		public virtual XmlNode ToXml()
		{
			MemoryStream output = new MemoryStream(512);
			XmlSerializer serializer = new XmlSerializer(typeof(EntityField));
			StreamWriter outputWriter = new StreamWriter(output);

			serializer.Serialize(outputWriter, this);
			output.Position = 0;

			XmlDocument newNode = new XmlDocument();
			newNode.Load(output);
			return newNode.SelectSingleNode("/*");
		}


		/// <summary>
		/// Converts this EntityField to an XmlNode. 
		/// </summary>
		/// <param name="parentDocument">the XmlDocument which will contain the node this method will return. This document is required
		/// to create the new node object</param>
		/// <param name="entityFieldNode">The output parameter which will represent this EntityField2 as XmlNode</param>
		public virtual void WriteXml(XmlDocument parentDocument, out XmlNode entityFieldNode)
		{
			entityFieldNode = parentDocument.CreateNode(XmlNodeType.Element, _name, "");
			
			XmlHelper nodeCreator = new XmlHelper();

			// create child nodes and attributes for this node.
			XmlNode childNode = nodeCreator.AddNode(entityFieldNode, "CurrentValue");

			string valueTypeName = _currentValue.GetType().UnderlyingSystemType.FullName.ToString();
			nodeCreator.AddAttribute(childNode, "Type", valueTypeName);

			// the value of this field can be of a variety of types. Some types require extra treatment before they can be
			// put as a value in an XmlNode.
			string valueAsString = String.Empty;

			if(_currentValue!=null)
			{
				switch(valueTypeName)
				{
					case "System.String":
					case "System.Byte":
					case "System.Int32":
					case "System.Int16":
					case "System.Int64":
					case "System.Decimal":
					case "System.Double":
					case "System.Single":
					case "System.Boolean":
					case "System.Guid":
						valueAsString = _currentValue.ToString();
						break;
					case "System.DateTime":
						valueAsString = ((DateTime)_currentValue).Ticks.ToString();
						break;
					case "System.Byte[]":
						// special case, base64encode it
						valueAsString = Convert.ToBase64String((byte[])_currentValue);
						break;
					default:
						valueAsString = _currentValue.ToString();
						break;
				}
			}
			childNode.AppendChild(parentDocument.CreateTextNode(valueAsString));

			childNode = nodeCreator.AddNode(entityFieldNode, "IsChanged", _isChanged.ToString());
			nodeCreator.AddAttribute(childNode, "Type", "System.Boolean");

			childNode = nodeCreator.AddNode(entityFieldNode, "IsNull", _isNull.ToString());
			nodeCreator.AddAttribute(childNode, "Type", "System.Boolean");
		}

		
		/// <summary>
		/// Accepts the value of the current value as the final current value. Original value is discarded
		/// </summary>
		public void AcceptChange()
		{
			if(!_isChanged)
			{
				// no change to accept
				return;
			}

			_originalValue = null;
			_isChanged = false;
		}


		/// <summary>
		/// Rejects the value of the current value and resets current value with the original value, and <see cref="IsChanged"/> will report false.
		/// </summary>
		public void RejectChange()
		{
			if(!_isChanged)
			{
				// no change to reject
				return;
			}

			_currentValue = _originalValue;
			_isChanged = false;
		}


		/// <summary>
		/// Initializes the class' member variables. for parameter descriptions, see the constructor(s).
		/// </summary>
		/// <param name="name"></param>
		/// <param name="dataType"></param>
		/// <param name="isReadOnly"></param>
		/// <param name="currentValue"></param>
		/// <param name="sourceSchemaName"></param>
		/// <param name="sourceObjectName"></param>
		/// <param name="sourceColumnName"></param>
		/// <param name="isSourceColumnNullable"></param>
		/// <param name="sourceColumnDbType"></param>
		/// <param name="sourceColumnMaxLength"></param>
		/// <param name="sourceColumnScale"></param>
		/// <param name="sourceColumnPrecision"></param>
		/// <param name="isPrimaryKey"></param>
		/// <param name="isIdentity"></param>
		/// <param name="identityValueSequenceName"></param>
		/// <param name="fieldIndex"></param>
		/// <param name="sourceCatalogName"></param>
		private void InitClass(string name, System.Type dataType, bool isReadOnly, object currentValue, string sourceSchemaName, string sourceObjectName, 
			string sourceColumnName, bool isSourceColumnNullable, int sourceColumnDbType, int sourceColumnMaxLength, byte sourceColumnScale, 
			byte sourceColumnPrecision, bool isPrimaryKey, bool isIdentity, string identityValueSequenceName, int fieldIndex, string sourceCatalogName)
		{
			_name = name;
			_dataType = dataType;
			_originalValue = null;
			_currentValue = currentValue;
			_isChanged = false;
			_isNull=false;
			_isReadOnly = isReadOnly;
			_sourceSchemaName = sourceSchemaName;
			_sourceObjectName = sourceObjectName;
			_sourceColumnName = sourceColumnName;
			_isSourceColumnNullable = isSourceColumnNullable;
			_sourceColumnDbType = sourceColumnDbType;
			_sourceColumnMaxLength = sourceColumnMaxLength;
			_sourceColumnPrecision = sourceColumnPrecision;
			_sourceColumnScale = sourceColumnScale;
			_isPrimaryKey = isPrimaryKey;
			_isIdentity = isIdentity;
			_identityValueSequenceName = identityValueSequenceName;
			_fieldIndex = fieldIndex;
			_sourceCatalogName = sourceCatalogName;
		}


		/// <summary>
		/// Creates a deep copy of this IEntityField object
		/// </summary>
		/// <returns>A deep copy of this object</returns>
		public virtual object Clone()
		{
			EntityField fieldToReturn = (EntityField)this.MemberwiseClone();

			// fill in the blanks.
			fieldToReturn.OriginalValue = _originalValue;
			fieldToReturn.ForcedCurrentValueWrite(_currentValue);

			return fieldToReturn;
		}


		/// <summary>
		/// Overwrites the current value with the value passed. This bypasses value checking and field properties like readonly. 
		/// Used by internal code only. Do not call this from your code.
		/// </summary>
		/// <param name="value">Value to store as the current value</param>
		public void ForcedCurrentValueWrite(object value)
		{
			_currentValue = value;
		}

		
		/// <summary>
		/// Forces a set of the IsChanged flag for this field. 
		/// </summary>
		/// <param name="isChangedValue">new value for IsChanged.</param>
		/// <remarks>Do not call this method from your code. This is an internal method</remarks>
		internal void ForcedChangedWrite(bool isChangedValue)
		{
			_isChanged = isChangedValue;
		}


		/// <summary>
		/// Overwrites DataType with the value specified without checking for type compatibility or readonly flags.
		/// </summary>
		/// <remarks>Do not call this method from your code. This is an internal method</remarks>
		/// <param name="dataType">Value to store as DataType</param>
		internal void ForcedTypeWrite(System.Type dataType)
		{
			_dataType = dataType;
		}


		/// <summary>
		/// IEditableObject method. Used by databinding.
		/// The field is kept marked changed, in effect, this method is empty.
		/// </summary>
		public void EndEdit()
		{
			// empty
		}


		/// <summary>
		/// IEditableObject method. Used by databinding.
		/// The currentvalue is reset by the original value.
		/// The field is marked unchanged.
		/// </summary>
		public void CancelEdit()
		{
			_currentValue = _originalValue;
			_isChanged = false;
		}

		
		/// <summary>
		/// IEditableObject method. Used by databinding.
		/// Original value is overwritten by currentValue, currentValue keeps its value.
		/// </summary>
		public void BeginEdit()
		{
			_originalValue = _currentValue;
		}


		#region Class Property Declarations
		/// <summary>
		/// The name of the catalog the SourceSchemaName is located in. 
		/// </summary>
		public string SourceCatalogName
		{
			get
			{
				return _sourceCatalogName;
			}
			set
			{
				_sourceCatalogName = value;
			}
		}


		/// <summary>
		/// The name of the schema which holds <see cref="SourceObjectName"/>. Schema is used to generate SQL on the fly. 
		/// A common schema name in SqlServer is f.e. 'dbo'.
		/// </summary>
		public string SourceSchemaName 
		{
			get { return _sourceSchemaName; }
			set { _sourceSchemaName = value; }
		}
			
		/// <summary>
		/// The name of the source object which holds <see cref="SourceColumnName"/>. Can be a view or a table. Used to generate SQL on the fly.
		/// </summary>
		public string SourceObjectName 
		{
			get { return _sourceObjectName; }
			set { _sourceObjectName = value; }
		}
			

		/// <summary>
		/// The name of the corresponding column in a view or table for this entityfield. This name is used to map a column in a resultset onto the entity field.
		/// Used for update/insert operations on the column
		/// </summary>
		public string SourceColumnName 
		{
			get { return _sourceColumnName; }
			set { _sourceColumnName = value; }
		}
		
		/// <summary>
		/// The maximum length of the value of this entityfield (string/binary data). Is ignored for entityfields which hold non-string and non-binary values.
		/// ColumnMaxLength
		/// Used for update/insert operations on the column
		/// </summary>
		public int SourceColumnMaxLength
		{
			get { return _sourceColumnMaxLength; }
			set { _sourceColumnMaxLength = value; }
		}
		
		/// <summary>
		/// The type of the Column mapped onto the EntityField. The value stored here is the integer representation of the enum value of the type, f.e.
		/// SqlDbType.Int or OracleType.Int16
		/// Used for update/insert operations on the column
		/// </summary>
		public int SourceColumnDbType
		{
			get { return _sourceColumnDbType; }
			set { _sourceColumnDbType = value; }
		}
		
		/// <summary>
		/// Flag if the Column mapped onto the entityfield is nullable or not. 
		/// Used for update/insert operations on the column
		/// </summary>
		public bool SourceColumnIsNullable
		{
			get { return _isSourceColumnNullable; }
			set { _isSourceColumnNullable = value; }
		}
		
		/// <summary>
		/// The scale of the Column mapped onto the entityfield.
		/// Used for update/insert operations on the column
		/// </summary>
		public byte SourceColumnScale
		{
			get { return _sourceColumnScale; }
			set { _sourceColumnScale = value; }
		}
		
		/// <summary>
		/// The precision of the Column mapped onto the entityfield.
		/// Used for update/insert operations on the column
		/// </summary>
		public byte SourceColumnPrecision
		{
			get { return _sourceColumnPrecision; }
			set { _sourceColumnPrecision = value; }
		}

		/// <summary>
		/// The name of the field. Used in XML output. 
		/// </summary>
		public string Name
		{
			get { return _name; }
			set 
			{ 
				if(value.Length <= 0)
				{
					// Names of zero length are rejected
					throw new ArgumentException("Name cannot be of zero length.");
				}
				if(value.Trim().Length <= 0)
				{
					throw new ArgumentException("Name has to contain other characters than just spaces.");
				}

				_name = value.Trim(); 
			}
		}


		/// <summary>
		/// The alias to use for this field. Only used when this field object is part of a typed list. 
		/// Adapter: returns the alias set in the designer
		/// SelfServicing: returns Name
		/// </summary>
		public string Alias 
		{
			get
			{
				return this.Name;
			}
			set
			{
				this.Name = value;
			}
		}


		/// <summary>
		/// The original value for this field when the field is changed and the change has not been accepted yet.
		/// </summary>
		internal object OriginalValue
		{
			get { return _originalValue;}
			set { _originalValue = value; }
		}
		
		
		/// <summary>
		/// Gets the current value for this field and sets the new value for this field, by overwriting current value. The value in 
		/// currentValue is discarded, versioning control has to save the original value of currentValue before this property is called. 
		/// </summary>
		/// <remarks>
		/// Calling this property directly will not trigger versioning control,
		/// thus calling this property directly is not recommended. Call <see cref="EntityBase.SetNewFieldValue"/> instead.
		/// Type of the new value has to be the same as <see cref="DataType"/>, which is set in the
		/// constructor. If this field is set to readonly, an exception is raised. 
		/// </remarks>
		/// <exception cref="ORMFieldIsReadonlyException">The field is set to readonly and can't be changed.</exception>
		/// <exception cref="ORMValueTypeMismatchException">The value specified is not of the same <see cref="DataType"/> as this field.</exception>
		public object CurrentValue
		{
			get { return _currentValue; }
			set 
			{ 
				if(value!=null)
				{
					if((_dataType!= typeof(object)) && (value.GetType() != _dataType))
					{
						throw new ORMValueTypeMismatchException("The value " + value.ToString() + " is of type '" + value.GetType().ToString() + "' while the field is of type '" + _dataType + "'");
					}
				}

				if(_isReadOnly)
				{
					throw new ORMFieldIsReadonlyException("The field is marked readonly and cannot be changed.");
				}

				_currentValue = value; 
				_isChanged = true;
			}
		}

		/// <summary>
		/// The <see cref="System.Type"/> of the values of this field.
		/// </summary>
		public System.Type DataType
		{
			get { return _dataType; }
		}
		
		/// <summary>
		/// If set to true, in the constructor, no changes can be made to this field. 
		/// </summary>
		public bool IsReadOnly
		{
			get { return _isReadOnly; }
		}
		
		/// <summary>
		/// If set to true, in the constructor, this field will end up in the PrimaryKey field list of the containing IEntityFields object.
		/// </summary>
		public bool IsPrimaryKey 
		{
			get { return _isPrimaryKey; }
		}

		/// <summary>
		/// If the value of this field is changed, this property is set to true. Set when <see cref="CurrentValue"/> receives a valid value. Set to 
		/// false when <see cref="AcceptChange"/> is called succesfully.
		/// </summary>
		public bool IsChanged
		{
			get { return _isChanged; }
			set { _isChanged = value; }
		}
		
		/// <summary>
		/// If the original value in the column for this entityfield is DBNull (NULL), this parameter should be set to true, otherwise to false.
		/// In BL Logic, it's impractical to work with NULL values, so these are converted to workable values. The developer can still determine if
		/// the original value was DBNull by checking this field. Using NULL values is not recommended. 
		/// </summary>
		public bool IsNull
		{
			get { return _isNull; }
			set	{ _isNull = value;}
		}

		/// <summary>
		/// If set to true, the Dynamic Query Engine (DQE) will assume the field is an Identity field and will act accordingly (i.e.: as the target database
		/// handles Identity fields: SqlServer will generate a new value itself, Oracle wants to have a sequence input.
		/// </summary>
		public bool IsIdentity 
		{
			get { return _isIdentity; }
		}

		/// <summary>
		/// If <see cref="IsIdentity"/> is set to true, this property has to be set to the name of the sequence which supplies the value for the EntityField's
		/// corresponding table field. On SqlServer this is @@IDENTITY or SCOPE_IDENTITY() and only used when the row is succesfully inserted, however on Oracle
		/// f.e. this value is used to specify a new value and to retrieve the new value. Is undefined when <see cref="IsIdentity"/> is set to false.
		/// </summary>
		public string IdentityValueSequenceName 
		{
			get { return _identityValueSequenceName; } 
		}

		/// <summary>
		/// Gets the field index related to this IEntityField, so the field can be used to retrieve the field index.
		/// </summary>
		public int FieldIndex 
		{
			get { return _fieldIndex; }
		}
		#endregion

	}
}
